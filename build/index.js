// Generated by CoffeeScript 1.10.0
var configure,
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

configure = function($) {
  var FileCompiler, JasmineCoffeeParser, JasmineConverter, MultiFileCompiler, Tokenizer;
  if ($ == null) {
    $ = {};
  }
  if ($.assign == null) {
    $.assign = function(target, source) {
      var key, results, val;
      results = [];
      for (key in source) {
        if (!hasProp.call(source, key)) continue;
        val = source[key];
        results.push(target[key] = val);
      }
      return results;
    };
  }
  if ($.require == null) {
    $.require = function(path) {
      return require(path);
    };
  }
  Tokenizer = (function() {
    Tokenizer.prototype.marked = null;

    function Tokenizer(props) {
      $.assign(this, props);
      if (this.marked == null) {
        this.marked = $.require("marked");
      }
    }

    Tokenizer.prototype.isExampleToken = function(mdToken) {
      return mdToken.type === "heading" && /^example/i.test(mdToken.text);
    };

    Tokenizer.prototype.isContextToken = function(mdToken) {
      return mdToken.type === "heading" && !this.isExampleToken(mdToken);
    };

    Tokenizer.prototype.isCodeToken = function(mdToken) {
      return mdToken.type === "code";
    };

    Tokenizer.prototype.createExampleToken = function(mdToken) {
      return {
        type: "example",
        text: mdToken.text,
        depth: mdToken.depth
      };
    };

    Tokenizer.prototype.createContextToken = function(mdToken) {
      return {
        type: "context",
        text: mdToken.text,
        depth: mdToken.depth
      };
    };

    Tokenizer.prototype.createCodeToken = function(mdToken) {
      return {
        type: "code",
        text: mdToken.text
      };
    };

    Tokenizer.prototype.processMarkdownToken = function(tokens, mdToken) {
      var createToken;
      createToken = (function() {
        switch (false) {
          case !this.isExampleToken(mdToken):
            return this.createExampleToken;
          case !this.isContextToken(mdToken):
            return this.createContextToken;
          case !this.isCodeToken(mdToken):
            return this.createCodeToken;
        }
      }).call(this);
      if (createToken != null) {
        tokens = tokens.concat(createToken(mdToken));
      }
      return tokens;
    };

    Tokenizer.prototype.tokenizeMarkdown = function(markdown) {
      return this.marked.lexer(markdown);
    };

    Tokenizer.prototype.tokenize = function(markdown) {
      var mdTokens;
      mdTokens = this.tokenizeMarkdown(markdown);
      return mdTokens.reduce(this.processMarkdownToken.bind(this), []);
    };

    return Tokenizer;

  })();
  JasmineConverter = (function() {
    function JasmineConverter(props) {
      if (props == null) {
        props = {};
      }
    }

    JasmineConverter.prototype.createDescribeToken = function(arg) {
      var depth, text;
      depth = arg.depth, text = arg.text;
      return {
        type: "describe",
        depth: depth,
        text: text
      };
    };

    JasmineConverter.prototype.createVarsToken = function(arg) {
      var depth, vars;
      depth = arg.depth, vars = arg.vars;
      return {
        type: "vars",
        depth: depth,
        vars: vars
      };
    };

    JasmineConverter.prototype.createBeforeEachToken = function(arg) {
      var code, depth;
      depth = arg.depth, code = arg.code;
      return {
        type: "beforeEach",
        depth: depth,
        code: code
      };
    };

    JasmineConverter.prototype.createItToken = function(arg) {
      var depth, text;
      depth = arg.depth, text = arg.text;
      return {
        type: "it",
        depth: depth,
        text: text.replace(/^example\:?\s*/, "")
      };
    };

    JasmineConverter.prototype.createAssertionToken = function(arg) {
      var code, depth;
      depth = arg.depth, code = arg.code;
      return {
        type: "assertion",
        depth: depth,
        code: code
      };
    };

    JasmineConverter.prototype.getVariableNames = function(code) {
      var reduceFn, tokens;
      tokens = require("coffee-script").tokens(code);
      reduceFn = function(vars, token) {
        var type, value;
        type = token[0], value = token[1];
        if (!(type === "IDENTIFIER" && token.variable)) {
          return vars;
        }
        if (vars.indexOf(value) !== -1) {
          return vars;
        }
        return vars.concat(value);
      };
      return tokens.reduce(reduceFn, []);
    };

    JasmineConverter.prototype.convert = function(tokens) {
      var currentContext, currentDepth, reduceTokens;
      currentDepth = 0;
      currentContext = null;
      reduceTokens = (function(_this) {
        return function(tokens, token) {
          var vars;
          if (token.depth != null) {
            currentDepth = token.depth;
          }
          if (token.type === "context") {
            currentContext = "describe";
            tokens.push(_this.createDescribeToken(token));
          }
          if (token.type === "example") {
            currentContext = "it";
            tokens.push(_this.createItToken(token));
          }
          if (token.type === "code" && currentContext === "describe") {
            vars = _this.getVariableNames(token.text);
            tokens.push(_this.createVarsToken({
              vars: vars,
              depth: currentDepth + 1
            }));
            tokens.push(_this.createBeforeEachToken({
              code: token.text,
              depth: currentDepth + 1
            }));
          }
          if (token.type === "code" && currentContext === "it") {
            tokens.push(_this.createAssertionToken({
              code: token.text,
              depth: currentDepth + 1
            }));
          }
          return tokens;
        };
      })(this);
      return tokens.reduce(reduceTokens, []);
    };

    return JasmineConverter;

  })();
  JasmineCoffeeParser = (function() {
    function JasmineCoffeeParser(props) {
      if (props == null) {
        props = {};
      }
    }

    JasmineCoffeeParser.prototype.parse = function(tokens) {
      var addDone, addSnippet, declareVar, declared, indent, isDeclared, replaceAssertionComments, snippets;
      declared = [['require', 'console', 'module', 'process']];
      snippets = [];
      indent = function(code, depth) {
        var i, indentation, j, ref;
        indentation = "";
        for (i = j = 1, ref = depth; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
          indentation += "  ";
        }
        return code.replace(/^/gm, indentation);
      };
      addSnippet = function(code, depth) {
        code = indent(code, depth);
        return snippets.push(code);
      };
      replaceAssertionComments = function(code) {
        var getAssertionCommentIndentation, getAssertionCommentSubject, getAssertionCommentTarget, transformAssertionComment;
        getAssertionCommentSubject = function(line) {
          var endIndex, startIndex;
          startIndex = /[^\s]/.exec(line).index;
          endIndex = line.indexOf(" # =>");
          return line.slice(startIndex, endIndex);
        };
        getAssertionCommentTarget = function(line) {
          return /\s# => (.*)$/.exec(line)[1];
        };
        getAssertionCommentIndentation = function(line) {
          return /^(\s*)/.exec(line)[1];
        };
        transformAssertionComment = function(line) {
          var indentation, subject, target;
          if (line.indexOf(" # =>") === -1) {
            return line;
          }
          subject = getAssertionCommentSubject(line);
          target = getAssertionCommentTarget(line);
          indentation = getAssertionCommentIndentation(line);
          return indentation + "expect(" + subject + ").toEqual(" + target + ")";
        };
        return code.split("\n").map(transformAssertionComment).join("\n");
      };
      addDone = function(code) {
        var lastSpacing, match, pattern;
        pattern = /^(\s*)([^\s]+)/gm;
        while (match = pattern.exec(code)) {
          lastSpacing = match[1];
        }
        if (lastSpacing == null) {
          lastSpacing = "";
        }
        return code += "\n" + lastSpacing + "done()";
      };
      isDeclared = function(v, depth) {
        var j, ref, results;
        return (function() {
          results = [];
          for (var j = ref = depth - 1; ref <= 0 ? j <= 0 : j >= 0; ref <= 0 ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this).some(function(d) {
          var ref;
          return indexOf.call((ref = declared[d]) != null ? ref : [], v) >= 0;
        });
      };
      declareVar = function(v, depth) {
        var d;
        d = declared[depth] != null ? declared[depth] : declared[depth] = [];
        if (d.indexOf(v) === -1) {
          return d.push(v);
        }
      };
      tokens.forEach(function(token) {
        var code, quotedText, vars;
        if (token.type === "describe") {
          quotedText = JSON.stringify(token.text);
          code = "describe " + quotedText + ", ->";
          addSnippet(code, token.depth);
        }
        if (token.type === "vars") {
          vars = [];
          token.vars.forEach(function(v) {
            if (!isDeclared(v, token.depth)) {
              vars.push(v);
            }
            return declareVar(v, token.depth);
          });
          if (vars.length === 0) {
            return;
          }
          code = "\n[" + (vars.join(", ")) + "] = []";
          addSnippet(code, token.depth);
        }
        if (token.type === "beforeEach") {
          code = "\nbeforeEach (done) ->\n";
          code = code + indent(token.code, 2);
          code = addDone(code);
          addSnippet(code, token.depth);
        }
        if (token.type === "it") {
          quotedText = JSON.stringify(token.text);
          code = "\nit " + quotedText + ", (done) ->";
          addSnippet(code, token.depth);
        }
        if (token.type === "assertion") {
          code = replaceAssertionComments(token.code);
          code = addDone(code);
          return addSnippet(code, token.depth);
        }
      });
      return snippets.join("\n") + "\n";
    };

    return JasmineCoffeeParser;

  })();
  FileCompiler = (function() {
    FileCompiler.prototype.tokenizer = null;

    FileCompiler.prototype.converter = null;

    FileCompiler.prototype.parser = null;

    function FileCompiler(props) {
      var key, val;
      if (props == null) {
        props = {};
      }
      for (key in props) {
        if (!hasProp.call(props, key)) continue;
        val = props[key];
        this[key] = val;
      }
      if (this.tokenizer == null) {
        this.tokenizer = new Tokenizer;
      }
      if (this.converter == null) {
        this.converter = new JasmineConverter;
      }
      if (this.parser == null) {
        this.parser = new JasmineCoffeeParser;
      }
    }

    FileCompiler.prototype.parse = function(markdown) {
      var tokens;
      tokens = this.tokenizer.tokenize(markdown);
      tokens = this.converter.convert(tokens);
      return this.parser.parse(tokens);
    };

    FileCompiler.prototype.readFile = function(path, done) {
      return require("fs").readFile(path, done);
    };

    FileCompiler.prototype.writeFile = function(path, data, done) {
      return require("fs").writeFile(path, data, done);
    };

    FileCompiler.prototype.compile = function(sourcePath, targetPath, done) {
      return this.readFile(sourcePath, (function(_this) {
        return function(error, data) {
          var compiled;
          if (error != null) {
            return done(error);
          }
          compiled = _this.parse(data.toString());
          return _this.writeFile(targetPath, compiled, done);
        };
      })(this));
    };

    return FileCompiler;

  })();
  MultiFileCompiler = (function() {
    function MultiFileCompiler(params) {
      var key, val;
      if (params == null) {
        params = {};
      }
      for (key in params) {
        if (!hasProp.call(params, key)) continue;
        val = params[key];
        this[key] = val;
      }
      if (this.cwd == null) {
        this.cwd = process.cwd();
      }
      if (this.fileCompiler == null) {
        this.fileCompiler = new FileCompiler;
      }
      if (this.sourceDir == null) {
        this.sourceDir = this.resolvePath(this.cwd, "docs");
      }
      if (this.targetDir == null) {
        this.targetDir = this.resolvePath(this.cwd, "spec");
      }
    }

    MultiFileCompiler.prototype.resolvePath = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = require("path")).resolve.apply(ref, args);
    };

    MultiFileCompiler.prototype.joinPath = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = require("path")).join.apply(ref, args);
    };

    MultiFileCompiler.prototype.eachSeries = function(series, fn, done) {
      return require("async").eachSeries(series, fn, done);
    };

    MultiFileCompiler.prototype.getTargetName = function(sourceName) {
      return sourceName.replace(/((\.coffee)?\.md|\.litcoffee)$/, "-spec.coffee");
    };

    MultiFileCompiler.prototype.compileSourceName = function(sourceName, done) {
      var sourcePath, targetName, targetPath;
      targetName = this.getTargetName(sourceName);
      sourcePath = this.joinPath(this.sourceDir, sourceName);
      targetPath = this.joinPath(this.targetDir, targetName);
      return this.fileCompiler.compile(sourcePath, targetPath, done);
    };

    MultiFileCompiler.prototype.glob = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return require("glob").apply(null, args);
    };

    MultiFileCompiler.prototype.compile = function(pattern, done) {
      if (pattern == null) {
        pattern = "**/*.?(md|litcoffee)";
      }
      return this.glob(pattern, {
        cwd: this.sourceDir
      }, (function(_this) {
        return function(error, sourceNames) {
          if (error) {
            return done(error);
          }
          return _this.eachSeries(sourceNames, _this.compileSourceName.bind(_this), done);
        };
      })(this));
    };

    return MultiFileCompiler;

  })();
  return {
    FileCompiler: FileCompiler,
    MultiFileCompiler: MultiFileCompiler,
    JasmineCoffeeParser: JasmineCoffeeParser,
    JasmineConverter: JasmineConverter,
    Tokenizer: Tokenizer
  };
};

module.exports = configure();

//# sourceMappingURL=index.js.map
