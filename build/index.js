// Generated by CoffeeScript 1.10.0
var configure,
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

configure = function($) {
  var CLI, Compiler, FileCompiler, JasmineCoffeeParser, JasmineConverter, MultiFileCompiler, Tokenizer;
  if ($ == null) {
    $ = {};
  }
  if ($.assign == null) {
    $.assign = function(target, source) {
      var key, results, val;
      results = [];
      for (key in source) {
        if (!hasProp.call(source, key)) continue;
        val = source[key];
        results.push(target[key] = val);
      }
      return results;
    };
  }
  if ($.require == null) {
    $.require = function(path) {
      return require(path);
    };
  }
  Compiler = (function() {
    function Compiler(props) {
      if (props == null) {
        props = {};
      }
      $.assign(this, props);
      if (this.tokenizer == null) {
        this.tokenizer = new Tokenizer;
      }
      if (this.converter == null) {
        this.converter = new JasmineConverter;
      }
      if (this.parser == null) {
        this.parser = new JasmineCoffeeParser;
      }
    }

    Compiler.prototype.compile = function(markdown) {
      var tokens;
      tokens = this.tokenizer.tokenize(markdown);
      tokens = this.converter.convert(tokens);
      return this.parser.parse(tokens);
    };

    return Compiler;

  })();
  Tokenizer = (function() {
    Tokenizer.prototype.marked = null;

    Tokenizer.prototype.defaultLanguage = null;

    function Tokenizer(props) {
      $.assign(this, props);
      if (this.marked == null) {
        this.marked = $.require("marked");
      }
    }

    Tokenizer.prototype.isExampleToken = function(mdToken) {
      return mdToken.type === "heading" && /^example/i.test(mdToken.text);
    };

    Tokenizer.prototype.isContextToken = function(mdToken) {
      return mdToken.type === "heading" && !this.isExampleToken(mdToken);
    };

    Tokenizer.prototype.isCodeToken = function(mdToken) {
      return mdToken.type === "code";
    };

    Tokenizer.prototype.createExampleToken = function(mdToken) {
      return {
        type: "example",
        text: mdToken.text,
        depth: mdToken.depth
      };
    };

    Tokenizer.prototype.createContextToken = function(mdToken) {
      return {
        type: "context",
        text: mdToken.text,
        depth: mdToken.depth
      };
    };

    Tokenizer.prototype.createCodeToken = function(mdToken) {
      return {
        type: "code",
        lang: mdToken.lang,
        text: mdToken.text
      };
    };

    Tokenizer.prototype.processMarkdownToken = function(tokens, mdToken) {
      var createToken, previous, token;
      createToken = (function() {
        switch (false) {
          case !this.isExampleToken(mdToken):
            return this.createExampleToken;
          case !this.isContextToken(mdToken):
            return this.createContextToken;
          case !this.isCodeToken(mdToken):
            return this.createCodeToken;
        }
      }).call(this);
      if (createToken == null) {
        return tokens;
      }
      token = createToken(mdToken);
      previous = tokens[tokens.length - 1];
      if (token.type === "code" && (previous != null ? previous.type : void 0) === "code" && (previous != null ? previous.lang : void 0) === token.lang) {
        previous.text = previous.text + "\n" + token.text;
        return tokens;
      }
      if (createToken != null) {
        tokens = tokens.concat(createToken(mdToken));
      }
      return tokens;
    };

    Tokenizer.prototype.tokenizeMarkdown = function(markdown) {
      return this.marked.lexer(markdown);
    };

    Tokenizer.prototype.tokenize = function(markdown) {
      var mdTokens;
      mdTokens = this.tokenizeMarkdown(markdown);
      return mdTokens.reduce(this.processMarkdownToken.bind(this), []);
    };

    return Tokenizer;

  })();
  JasmineConverter = (function() {
    JasmineConverter.prototype.globalVariables = null;

    function JasmineConverter(props) {
      if (props == null) {
        props = {};
      }
      if (this.globalVariables == null) {
        this.globalVariables = ["Infinity", "NaN", "undefined", "null", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Object", "Function", "Boolean", "Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "Number", "Math", "Date", "String", "Symbol", "RegExp", "Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "Map", "Set", "WeakMap", "WeakSet", "SIMD", "ArrayBuffer", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "Reflect", "Proxy", "arguments", "require", "console", "module", "process", "window", "jasmine", "spyOn"];
      }
    }

    JasmineConverter.prototype.createDescribeToken = function(arg) {
      var depth, text;
      depth = arg.depth, text = arg.text;
      return {
        type: "describe",
        depth: depth,
        text: text
      };
    };

    JasmineConverter.prototype.createVarsToken = function(arg) {
      var depth, vars;
      depth = arg.depth, vars = arg.vars;
      return {
        type: "vars",
        depth: depth,
        vars: vars
      };
    };

    JasmineConverter.prototype.createBeforeEachToken = function(arg) {
      var code, depth;
      depth = arg.depth, code = arg.code;
      return {
        type: "beforeEach",
        depth: depth,
        code: code
      };
    };

    JasmineConverter.prototype.createItToken = function(arg) {
      var depth, text;
      depth = arg.depth, text = arg.text;
      return {
        type: "it",
        depth: depth,
        text: text.replace(/^example\:?\s*/, "")
      };
    };

    JasmineConverter.prototype.createAssertionToken = function(arg) {
      var code, depth;
      depth = arg.depth, code = arg.code;
      return {
        type: "assertion",
        depth: depth,
        code: code
      };
    };

    JasmineConverter.prototype.getVariableNames = function(code) {
      var reduceFn, tokens;
      tokens = require("coffee-script").tokens(code);
      reduceFn = (function(_this) {
        return function(vars, token) {
          var type, value;
          type = token[0], value = token[1];
          if (!(type === "IDENTIFIER" && token.variable)) {
            return vars;
          }
          if (vars.indexOf(value) !== -1) {
            return vars;
          }
          if (_this.globalVariables.indexOf(value) !== -1) {
            return vars;
          }
          return vars.concat(value);
        };
      })(this);
      return tokens.reduce(reduceFn, []);
    };

    JasmineConverter.prototype.convert = function(tokens) {
      var currentContext, currentDepth, reduceTokens;
      currentDepth = 0;
      currentContext = null;
      reduceTokens = (function(_this) {
        return function(tokens, token) {
          var vars;
          if (token.depth != null) {
            currentDepth = token.depth;
          }
          if (token.type === "context") {
            currentContext = "describe";
            tokens.push(_this.createDescribeToken(token));
          }
          if (token.type === "example") {
            currentContext = "it";
            tokens.push(_this.createItToken(token));
          }
          if (token.type === "code" && currentContext === "describe") {
            vars = _this.getVariableNames(token.text);
            tokens.push(_this.createVarsToken({
              vars: vars,
              depth: currentDepth + 1
            }));
            tokens.push(_this.createBeforeEachToken({
              code: token.text,
              depth: currentDepth + 1
            }));
          }
          if (token.type === "code" && currentContext === "it") {
            tokens.push(_this.createAssertionToken({
              code: token.text,
              depth: currentDepth + 1
            }));
          }
          return tokens;
        };
      })(this);
      return tokens.reduce(reduceTokens, []);
    };

    return JasmineConverter;

  })();
  JasmineCoffeeParser = (function() {
    function JasmineCoffeeParser(props) {
      if (props == null) {
        props = {};
      }
    }

    JasmineCoffeeParser.prototype.parse = function(tokens) {
      var addDone, addSnippet, declareVar, declared, indent, isDeclared, removeTrailingWhiteSpace, replaceAssertionComments, result, snippets;
      declared = [];
      snippets = [];
      removeTrailingWhiteSpace = function(code) {
        return code.replace(/[ \t]+$/gm, "");
      };
      indent = function(code, depth) {
        var i, indentation, j, ref;
        indentation = "";
        for (i = j = 1, ref = depth; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
          indentation += "  ";
        }
        return code.replace(/^/gm, indentation);
      };
      addSnippet = function(code, depth) {
        code = indent(code, depth);
        return snippets.push(code);
      };
      replaceAssertionComments = function(code) {
        var getAssertionCommentIndentation, getAssertionCommentSubject, getAssertionCommentTarget, transformAssertionComment;
        getAssertionCommentSubject = function(line) {
          var endIndex, startIndex;
          startIndex = /[^\s]/.exec(line).index;
          endIndex = line.indexOf(" # =>");
          return line.slice(startIndex, endIndex);
        };
        getAssertionCommentTarget = function(line) {
          return /\s# => (.*)$/.exec(line)[1];
        };
        getAssertionCommentIndentation = function(line) {
          return /^(\s*)/.exec(line)[1];
        };
        transformAssertionComment = function(line) {
          var indentation, subject, target;
          if (line.indexOf(" # =>") === -1) {
            return line;
          }
          subject = getAssertionCommentSubject(line);
          target = getAssertionCommentTarget(line);
          indentation = getAssertionCommentIndentation(line);
          return indentation + "expect(" + subject + ").toEqual(" + target + ")";
        };
        return code.split("\n").map(transformAssertionComment).join("\n");
      };
      addDone = function(code) {
        var lastSpacing, match, pattern;
        pattern = /^(\s*)([^\s]+)/gm;
        while (match = pattern.exec(code)) {
          lastSpacing = match[1];
        }
        if (lastSpacing == null) {
          lastSpacing = "";
        }
        return code += "\n" + lastSpacing + "done()";
      };
      isDeclared = function(v, depth) {
        var j, ref, results;
        return (function() {
          results = [];
          for (var j = ref = depth - 1; ref <= 0 ? j <= 0 : j >= 0; ref <= 0 ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this).some(function(d) {
          var ref;
          return indexOf.call((ref = declared[d]) != null ? ref : [], v) >= 0;
        });
      };
      declareVar = function(v, depth) {
        var d;
        d = declared[depth] != null ? declared[depth] : declared[depth] = [];
        if (d.indexOf(v) === -1) {
          return d.push(v);
        }
      };
      tokens.forEach(function(token) {
        var code, quotedText, vars;
        if (token.type === "describe") {
          quotedText = JSON.stringify(token.text);
          code = "describe " + quotedText + ", ->";
          if (token.depth !== 1) {
            code = "\n" + code;
          }
          addSnippet(code, token.depth);
        }
        if (token.type === "vars") {
          vars = [];
          token.vars.forEach(function(v) {
            if (!isDeclared(v, token.depth)) {
              vars.push(v);
            }
            return declareVar(v, token.depth);
          });
          if (vars.length === 0) {
            return;
          }
          code = "\n[" + (vars.join(", ")) + "] = []";
          addSnippet(code, token.depth);
        }
        if (token.type === "beforeEach") {
          code = "\nbeforeEach ->\n";
          code = code + indent(token.code, 2);
          addSnippet(code, token.depth);
        }
        if (token.type === "it") {
          quotedText = JSON.stringify(token.text);
          code = "\nit " + quotedText + ", (done) ->";
          addSnippet(code, token.depth);
        }
        if (token.type === "assertion") {
          code = replaceAssertionComments(token.code);
          code = addDone(code);
          return addSnippet(code, token.depth);
        }
      });
      result = snippets.join("\n") + "\n";
      return removeTrailingWhiteSpace(result);
    };

    return JasmineCoffeeParser;

  })();
  FileCompiler = (function() {
    FileCompiler.prototype.compiler = null;

    function FileCompiler(props) {
      var key, val;
      if (props == null) {
        props = {};
      }
      for (key in props) {
        if (!hasProp.call(props, key)) continue;
        val = props[key];
        this[key] = val;
      }
      if (this.compiler == null) {
        this.compiler = new Compiler;
      }
    }

    FileCompiler.prototype.compile = function(sourcePath, targetPath, done) {
      return this.readFile(sourcePath, (function(_this) {
        return function(error, data) {
          var compiled;
          if (error != null) {
            return done(error);
          }
          compiled = _this.compiler.compile(data.toString());
          return _this.writeFile(targetPath, compiled, function(error) {
            if (error != null) {
              return done(error);
            }
            return done(null, compiled);
          });
        };
      })(this));
    };

    FileCompiler.prototype.readFile = function(path, done) {
      return require("fs").readFile(path, done);
    };

    FileCompiler.prototype.writeFile = function(path, data, done) {
      return require("fs").writeFile(path, data, done);
    };

    return FileCompiler;

  })();
  MultiFileCompiler = (function() {
    function MultiFileCompiler(params) {
      var key, val;
      if (params == null) {
        params = {};
      }
      for (key in params) {
        if (!hasProp.call(params, key)) continue;
        val = params[key];
        this[key] = val;
      }
      if (this.cwd == null) {
        this.cwd = process.cwd();
      }
      if (this.fileCompiler == null) {
        this.fileCompiler = new FileCompiler;
      }
      if (this.sourceDir == null) {
        this.sourceDir = this.resolvePath(this.cwd, "docs");
      }
      if (this.targetDir == null) {
        this.targetDir = this.resolvePath(this.cwd, "spec");
      }
    }

    MultiFileCompiler.prototype.resolvePath = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = require("path")).resolve.apply(ref, args);
    };

    MultiFileCompiler.prototype.joinPath = function() {
      var args, ref;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref = require("path")).join.apply(ref, args);
    };

    MultiFileCompiler.prototype.eachSeries = function(series, fn, done) {
      return require("async").eachSeries(series, fn, done);
    };

    MultiFileCompiler.prototype.getTargetName = function(sourceName) {
      return sourceName.replace(/((\.coffee)?\.md|\.litcoffee)$/, "-spec.coffee");
    };

    MultiFileCompiler.prototype.compileSourceName = function(sourceName, done) {
      var sourcePath, targetName, targetPath;
      targetName = this.getTargetName(sourceName);
      sourcePath = this.joinPath(this.sourceDir, sourceName);
      targetPath = this.joinPath(this.targetDir, targetName);
      return this.fileCompiler.compile(sourcePath, targetPath, done);
    };

    MultiFileCompiler.prototype.glob = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return require("glob").apply(null, args);
    };

    MultiFileCompiler.prototype.compile = function() {
      var compilePattern, done, j, patterns;
      patterns = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), done = arguments[j++];
      if (patterns.length === 0) {
        patterns = ["**/*.?(md|litcoffee)"];
      }
      compilePattern = (function(_this) {
        return function(pattern, done) {
          return _this.glob(pattern, {
            cwd: _this.sourceDir
          }, function(error, sourceNames) {
            if (error) {
              return done(error);
            }
            return _this.eachSeries(sourceNames, _this.compileSourceName.bind(_this), done);
          });
        };
      })(this);
      return this.eachSeries(patterns, compilePattern, done);
    };

    return MultiFileCompiler;

  })();
  CLI = (function() {
    CLI.prototype.multiFileCompiler = null;

    function CLI(props) {
      if (props == null) {
        props = {};
      }
      $.assign(this, props);
      if (this.multiFileCompiler == null) {
        this.multiFileCompiler = new MultiFileCompiler;
      }
    }

    CLI.prototype.getUsageBanner = function() {
      return $0 + " [file|pattern]...\nCompile the specified files/patterns.";
    };

    CLI.prototype.run = function(done) {
      var argv, patterns, ref, yargs;
      yargs = require("yargs");
      argv = yargs.argv;
      patterns = argv._;
      return (ref = this.multiFileCompiler).compile.apply(ref, slice.call(patterns).concat([function(error) {
        if (error != null) {
          throw error;
        }
        return process.exit(0);
      }]));
    };

    return CLI;

  })();
  return {
    CLI: CLI,
    Compiler: Compiler,
    FileCompiler: FileCompiler,
    MultiFileCompiler: MultiFileCompiler,
    JasmineCoffeeParser: JasmineCoffeeParser,
    JasmineConverter: JasmineConverter,
    Tokenizer: Tokenizer
  };
};

module.exports = configure();

//# sourceMappingURL=index.js.map
